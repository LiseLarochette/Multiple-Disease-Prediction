# -*- coding: utf-8 -*-
"""projet_3_diabetes.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1friDfb8dmUvgJ3xmNpHxYDAYJ4KkHJMN
"""

# -*- coding: utf-8 -*-
"""Projet3_final_LAMAND_Christophe_17_06_2024.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vMuJdzHo0QLttIBqdxx8tbhpb90Vy8B-
"""

import pandas as pd

df_diabete = pd.read_csv("df_diabete_clean_zero.csv").drop(columns="Unnamed: 0")

from sklearn.pipeline import Pipeline
from sklearn.preprocessing import MaxAbsScaler
from sklearn.linear_model import LogisticRegression
from sklearn.model_selection import train_test_split
from sklearn.metrics import confusion_matrix, classification_report
from imblearn.over_sampling import SMOTE
from imblearn.under_sampling import RandomUnderSampler
from imblearn.pipeline import Pipeline as ImbPipeline

# Charger les données
X = df_diabete.drop(columns=['Outcome'])
y = df_diabete['Outcome']

# Diviser les données en ensembles d'entraînement et de test
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.5, random_state=42, stratify=y)

# Définir les techniques de rééchantillonnage
over_sampler = SMOTE(random_state=42)
under_sampler = RandomUnderSampler(random_state=42)

# Créer le pipeline avec MaxAbsScaler, SMOTE, RandomUnderSampler, et Logistic Regression
pipeline = ImbPipeline([
    ('scaler', MaxAbsScaler()),
    ('over', over_sampler),
    ('under', under_sampler),
    ('model', LogisticRegression(random_state=42))
])

# Entraîner le pipeline
pipeline.fit(X_train, y_train)

# Prédictions sur l'ensemble de test
y_pred = pipeline.predict(X_test)

def prediction_diabete(liste):
  if pipeline.predict(liste)[0] == 0 :
    return "Le risque potentiel n'est pas détecté sur la maladie du diabète"
  else :
    return "Le risque potentiel sur la maladie du diabète est détecté"
